 ###STARTLIST###
[
  {
    "testname": "Test Bootup Process", 
    "testcase": {
      "testname": "Test Bootup Process",
      "objective": "Validate that the MX485 router boots up successfully and all expected services start",
      "steps": [
        "Junos OS boots up", 
        "Routing protocols initialize",
        "High availability subsystems become ready"
      ],
      "test_data": {
        "router_model": "MX485", 
        "junos_version": "Junos 21.4R1",
        "redundancy_protocol": "Bidirectional Forwarding Detection" 
      }
    },
    "testscript": {
      "testname": "Test Bootup Process",
      "objective": "Script to validate bootup process on MX485",
      "file_name": "test_bootup.py",
      "init_scripts": [
        "pip install pytest",
        "pip install paramiko"
      ],
      "script": "\"\"\"
        1. Establish SSH connection to MX485
        2. Check if expected Junos version is running
        3. Verify all expected routing protocols are initialized
        4. Confirm HA redundancy protocol is up
        \"\"\",
      "run_command": "python test_bootup.py",
      "expected_result": "All test steps pass"
    }
  },
  
  {
    "testname": "Test Routing Protocol Convergence",
    "testcase": {
      "testname": "Test Routing Protocol Convergence",
      "objective": "Validate OSPF and BGP routing protocols converge as expected",
      "steps": [
        "Bring up new OSPF neighbor relationship",
        "Verify OSPF database synchronization", 
        "Establish eBGP peering",
        "Confirm routes exchanged over eBGP"
      ],
      "test_data": {
        "protocols": ["OSPF", "BGP"],
        "ospf_areas": [0, 1],
        "bgp_asns": [65000, 65001]
      }
    },
    "testscript": {
      "testname": "Test Routing Protocol Convergence",
      "objective": "Script to test routing protocol convergence",  
      "file_name": "test_routing_convergence.py",
      "init_scripts": [ 
        "pip install napalm"
      ],
      "script": "\"\"\"
        1. Configure new OSPF neighbor
        2. Check OSPF database sync using napalm
        3. Configure eBGP peering
        4. Verify routes exchanged over eBGP
        \"\"\",
      "run_command": "python test_routing_convergence.py",
      "expected_result": "OSPF and BGP converge as expected"
    }
  }
]
###ENDLIST### ###STARTLIST###
[
  {
    "testname": "Test Port Mappings", 
    "testcase": {
      "testname": "Test Port Mappings",
      "objective": "Verify all physical ports on the MX485 are mapped correctly to logical interfaces after bootup.",
      "steps": [
        "1. Check mappings between physical ports and logical interfaces in output of 'show chassis hardware'", 
        "2. Verify all expected 48 physical ports are mapped to logical interfaces ge-0/0/0 to ge-0/0/47"
      ],
      "test_data": {
        "logical_interfaces": ["ge-0/0/0", "ge-0/0/1", ..., "ge-0/0/47"], 
        "physical_ports": [ "PIC 0", "PIC 1", ..., "PIC 47"] 
      }
    },
    "testscript": {
      "testname": "Test Port Mappings",
      "objective": "Verify port mappings after bootup",
      "file_name": "test_portmappings.py",
      "init_scripts": "import json\nimport unittest\nfrom ncclient import manager\nimport xml.etree.ElementTree as ET",
      "script": \"\"\"
      def test_portmappings(self):
          with manager.connect(host='192.168.0.1', port=830,username='netconf', password='juniper123') as m:
              c = m.get_config(source='running').data_xml
              root = ET.fromstring(c)
              mappings = [(i.text, i.attrib['operation']) for i in root.findall(\".//logical-interface\") if 'operation' in i.attrib]
              self.assertEqual(len(mappings), 48)
              self.assertCountEqual(mappings, [(f'ge-0/0/{i}', 'delete') for i in range(48)])
      \"\"\",
      "run_command": "python test_portmappings.py",
      "expected_result": "OK"
    }
  },

  {
    "testname": "Test Interface Addresses",
    "testcase": {
      "testname": "Test Interface Addresses",
      "objective": "Verify all interfaces have expected IP addresses assigned after bootup.",
      "steps": [
        "1. Use PyEZ NETCONF to retrieve interface configurations", 
        "2. Check 'inet' blocks for expected addresses on interfaces"
      ],
      "test_data": {
        "expected_addresses": {
          "ge-0/0/0": ["10.0.0.1/24"],
          "ge-0/0/1": ["10.0.1.1/24"]
        }  
      }
    },
    "testscript": {
      "testname": "Test Interface Addresses",
      "objective": "Verify interface IP addresses",  
      "file_name": "test_addrs.py",
      "init_scripts": "import json\nimport unittest\nfrom ncclient import manager\nimport xml.etree.ElementTree as ET",
      "script": \"\"\"
      def test_addrs(self):
          with manager.connect(host='192.168.0.1', port=830,username='netconf', password='juniper123') as m:
              c = m.get_config(source='running').data_xml
              root = ET.fromstring(c)
              addresses = {i.text: i.find('inet/address/name').text for i in root.findall(\".//interface\") if i.find('inet/address/name') is not None} 
              self.assertDictEqual(addresses, expected_addresses)
      \"\"\",
      "run_command": "python test_addrs.py", 
      "expected_result": "OK"
    }
  }
]
###ENDLIST### ###STARTLIST###
[
  {
    "testname": "Bootup Port Test", 
    "testcase": {
      "testname": "Bootup Port Test",
      "objective": "Verify all ports initialize and are up during bootup process",
      "steps": [
        "Check if all ports are up after bootup completes", 
        "Verify no port errors or down ports logged"
      ],
      "test_data": {
        "num_ports": 96,
        "port_speed": 100Gb
      }
    },
    "testscript": {
      "testname": "Bootup Port Test",
      "objective": "Verify all ports initialize and are up during bootup process", 
      "file_name": "bootup_port_test.py",
      "init_scripts": [
        "pip install paramiko",
        "pip install netmiko"
      ],
      "script": \"\"\"
import paramiko
import netmiko

NUM_PORTS = 96
PORT_SPEED = 100Gb

ssh_client = paramiko.SSHClient()
ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
ssh_client.connect('192.168.0.1', username='testuser', password='testpassword')

connection = ssh_client.invoke_shell()
connection.send('show interfaces terse\\n')
output = connection.recv(10000)

num_up_ports = 0
for line in output.split('\\n'):
  if 'up' in line:
    num_up_ports += 1

if num_up_ports == NUM_PORTS:
  print('All ports up after bootup')
else:
  print(f'Ports down after bootup: {NUM_PORTS - num_up_ports}') 

connection.close()
ssh_client.close()
\"\"\"",
      "run_command": "python bootup_port_test.py",
      "expected_result": "All ports up after bootup"
    }
  },
  {
    "testname": "Bootup Protocol Test",
    "testcase": {
      "testname": "Bootup Protocol Test",
      "objective": "Verify routing protocols establish adjacencies after bootup",
      "steps": [ 
        "Check OSPF neighbors after bootup",
        "Check BGP peers/neighbors after bootup"
      ],
      "test_data": {
        "ospf_neighbors": 10,
        "bgp_peers": 5  
      }
    },
    "testscript": {
      "testname": "Bootup Protocol Test",
      "objective": "Verify routing protocols establish adjacencies after bootup",
      "file_name": "bootup_protocol_test.py",
      "init_scripts": [
        "pip install paramiko"
      ],
      "script": \"\"\"  
import paramiko

OSPF_NEIGHBORS = 10
BGP_PEERS = 5

ssh_client = paramiko.SSHClient()
ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
ssh_client.connect('192.168.0.1', username='testuser', password='testpassword')

connection = ssh_client.invoke_shell()
connection.send('show ospf neighbor\\n')
ospf_output = connection.recv(10000)

num_ospf_neighbors = len(ospf_output.split('\\n')) - 1

connection.send('show bgp summary \\n')
bgp_output = connection.recv(10000)

num_bgp_peers = len(bgp_output.split('\\n')) - 1

if num_ospf_neighbors == OSPF_NEIGHBORS and num_bgp_peers == BGP_PEERS:
  print('OSPF and BGP protocols up with required adjacencies')  
else:
  print('Protocols not up with required adjacencies')

connection.close() 
ssh_client.close()
\"\"\"",
      "run_command": "python bootup_protocol_test.py", 
      "expected_result": "OSPF and BGP protocols up with required adjacencies"
    }
  }
]
###ENDLIST###