 ###STARTLIST###
[
  {
    "testname": "ECMP Load Balancing Basic Test", 
    "testcase": {
      "testname": "ECMP Load Balancing Basic Test",
      "objective": "Verify basic ECMP load balancing functionality", 
      "steps": [
        "Configure 2 equal cost paths between R1 and R2", 
        "Send traffic from R1 to R2",
        "Verify traffic is load balanced across both paths"
      ],
      "testdata": {
        "num_paths": 2,
        "traffic_type": "UDP",
        "packet_count": 1000
      }
    },
    "testscript": {
      "testname": "ECMP Load Balancing Basic Test",
      "objective": "Automate ECMP load balancing test",
      "file_name": "test_ecmp_basic.py",
      "init_scripts": "pip install paramiko",
      "script": """
        import paramiko
        
        R1_IP = '192.168.0.1'
        R1_USER = 'testuser'
        R1_PASS = 'testpass'
        
        R2_IP = '192.168.0.2'
        
        client = paramiko.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        
        client.connect(R1_IP, username=R1_USER, password=R1_PASS)
        
        # Configure ECMP paths
        client.exec_command('configure 2 equal cost paths between R1 and R2')
        
        # Send test traffic
        client.exec_command('send 1000 UDP packets from R1 to R2')
        
        # Verify traffic balancing
        stdin, stdout, stderr = client.exec_command('show traffic-engineering bgp-instance summary')
        load_balance_output = stdout.read().decode()
        
        if '500 packets on path 1' in load_balance_output and '500 packets on path 2' in load_balance_output:
          print('ECMP load balancing verified')
        else:
          print('ECMP load balancing failed')
          
        client.close()
      """,
      "run_command": "python test_ecmp_basic.py",
      "expected_result": "ECMP load balancing verified"
    }
  },
  
  {
    "testname": "ECMP Unequal Cost Paths Test",
    "testcase": {
      "testname": "ECMP Unequal Cost Paths Test",
      "objective": "Verify ECMP across unequal cost paths",
      "steps": [
        "Configure 2 paths between R1 and R2 with different costs",
        "Send traffic from R1 to R2",
        "Verify more traffic uses lower cost path"  
      ],
      "testdata": {
        "path1_cost": 100,
        "path2_cost": 200,
        "traffic_type": "TCP",
        "packet_count": 2000
      }
    },  
    "testscript": {
      "testname": "ECMP Unequal Cost Paths Test",
      "objective": "Automate test for ECMP across unequal cost paths",
      "file_name": "test_ecmp_unequal.py",
      "init_scripts": "pip install netmiko",
      "script": """
        from netmiko import ConnectHandler
        
        R1 = {
          'device_type': 'juniper',
          'ip': '192.168.0.1',
          'username': 'testuser',
          'password': 'testpass'
        }
        
        R2 = {
          'device_type': 'juniper',
          'ip': '192.168.0.2',
          'username': 'testuser',
          'password': 'testpass'
        }
        
        def configure_unequal_paths():
          # Config code here
          pass
          
        def send_test_traffic():
          # Traffic generation code here
          pass
          
        def verify_load_balancing():
          # Parse output to validate more traffic on lower cost path
          pass
          
        with ConnectHandler(**R1) as r1, ConnectHandler(**R2) as r2:
          configure_unequal_paths()
          
          send_test_traffic()
          
          verify_load_balancing()
      """,  
      "run_command": "python test_ecmp_unequal.py",
      "expected_result": "More traffictraversed lower cost path"
    }
  }
]
###ENDLIST### Here are 2 Integration Test cases and Python test scripts for ECMP load balancing on Juniper MX481 focusing on ports and address verification:

###STARTLIST###
[
{
  "testname": "Test ECMP Port Mapping",
  "testcase": {
    "testname": "Test ECMP Port Mapping", 
    "objective": "Verify ECMP load balances traffic across configured ports",
    "steps": [
      "Configure ECMP with ports ge-0/0/1 and ge-0/0/2",
      "Send traffic to device under test",
      "Verify traffic is load balanced across both ports"
    ],
    "test_data": {
      "ports": ["ge-0/0/1", "ge-0/0/2"],
      "packet_count": 1000,
      "expected_distribution": 50
    }
  },

  "testscript": {
    "testname": "Test ECMP Port Mapping",
    "objective": "Verify ECMP load balances traffic across configured ports", 
    "file_name": "test_ecmp_port_mapping.py",
    "init_scripts": [
      "pip install paramiko",
      "pip install scp"
    ],
    "script": """
import paramiko
import scp

# SSH into DUT to configure ECMP
ssh = paramiko.SSHClient()
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
ssh.connect('dut_ip', username='admin', password='password')

ssh.exec_command('set interfaces ge-0/0/1 unit 0 family inet address 1.1.1.1/24')
ssh.exec_command('set interfaces ge-0/0/2 unit 0 family inet address 2.2.2.2/24')
ssh.exec_command('set routing-options static route 0.0.0.0/0 equal-cost paths 2') 
ssh.exec_command('set routing-options static route 0.0.0.0/0 equal-cost-paths path1 interface ge-0/0/1')
ssh.exec_command('set routing-options static route 0.0.0.0/0 equal-cost-paths path2 interface ge-0/0/2')

# Send test traffic
sender = RemoteHost('sender_ip')
sender.start_traffic(ports=[1, 2], packet_count=1000)

# Analyze packet capture on receiver
receiver = RemoteHost('receiver_ip')
pcap = receiver.get_pcap()
counts = analyze_pcap(pcap)

# Verify distribution across ports  
expected_dist = 50
actual_dist = abs(counts[0] - counts[1])
assert actual_dist <= (expected_dist * 0.1), 'Traffic not balanced'
""",

    "run_command": "python test_ecmp_port_mapping.py",
    "expected_result": "Traffic balanced across ports within 10% threshold"
  }
},

{
  "testname": "Test ECMP Address Verification",
  
  "testcase": {
    "testname": "Test ECMP Address Verification",
    "objective": "Verify ECMP load balances traffic to correct next hop addresses",
    "steps": [
      "Configure ECMP with next hops 1.1.1.1 and 2.2.2.2", 
      "Send traffic to device under test",
      "Verify traffic received at both configured next hop addresses"
    ],
    "test_data": {
      "next_hops": ["1.1.1.1", "2.2.2.2"], 
      "packet_count": 1000,
      "expected_distribution": 50
    }
  },

  "testscript": {
    "testname": "Test ECMP Address Verification",
    "objective": "Verify ECMP load balances traffic to correct next hop addresses",
    "file_name": "test_ecmp_address.py",
    "init_scripts": [
      "pip install paramiko",
      "pip install scp"
    ],
    "script": """  
import paramiko
import scp

# SSH into DUT to configure ECMP
ssh = paramiko.SSHClient()
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
ssh.connect('dut_ip', username='admin', password='password')

ssh.exec_command('set interfaces ge-0/0/1 unit 0 family inet address 1.1.1.1/24')
ssh.exec_command('set interfaces ge-0/0/2 unit 0 family inet address 2.2.2.2/24')  
ssh.exec_command('set routing-options static route 0.0.0.0/0 equal-cost paths 2')
ssh.exec_command('set routing-options static route 0.0.0.0/0 equal-cost-paths path1 next-hop 1.1.1.1') 
ssh.exec_command('set routing-options static route 0.0.0.0/0 equal-cost-paths path2 next-hop 2.2.2.2')

# Send test traffic
sender = RemoteHost('sender_ip')
sender.start_traffic(destination_ips=['1.1.1.1', '2.2.2.2'], packet_count=1000)

# Analyze packet capture 
receiver1 = RemoteHost('1.1.1.1')
receiver2 = RemoteHost('2.2.2.2')
pcap1 = receiver1.get_pcap()
pcap2 = receiver2.get_pcap()
counts = analyze_pcaps(pcap1, pcap2)

# Verify distribution across next-hops
expected_dist = 50  
actual_dist = abs(counts[0] - counts[1])
assert actual_dist <= (expected_dist * 0.1), 'Traffic not balanced'
""",

    "run_command": "python test_ecmp_address.py",
    "expected_result": "Traffic received at configured next hop addresses" 
  }
}
]
###ENDLIST### ###STARTLIST###
[
  {
    "testname": "ECMP Load Balancing - Port 1", 
    "testcase": {
      "testname": "ECMP Load Balancing - Port 1",
      "objective": "Verify traffic is equally load balanced across all ports when ECMP routing is enabled",
      "steps": [
        "Configure ECMP routing with all ports active", 
        "Send test traffic from traffic generator",
        "Verify packet counts are approximately equal on all ports"
      ],
      "testdata": {
        "num_ports": 8,
        "expected_deviation": 10
      }
    },
    "testscript": {
      "testname": "ECMP Load Balancing - Port 1",
      "objective": "Generate and send test traffic for port 1",
      "file_name": "port1_traffic.py",
      "init_scripts": [
        "pip install scapy",
        "pip install paramiko",
        """
        import paramiko
        import time
        from scapy.all import *
        
        #Send test traffic
        src_mac = "00:00:00:00:00:01"
        dst_mac = "00:00:00:00:00:02"
        
        for i in range(100):
            sendp(Ether(src=src_mac, dst=dst_mac)/IP(dst="10.0.0.1")/TCP())
            time.sleep(1)
        """,
        "python port1_traffic.py",
        "No errors while generating and sending test traffic on port 1."  
      ]
    }
  },

  {
    "testname": "ECMP Load Balancing - Port 2",
    "testcase": {
      "testname": "ECMP Load Balancing - Port 2",
      "objective": "Verify traffic is equally load balanced across all ports when ECMP routing is enabled",
      "steps": [
        "Configure ECMP routing with all ports active",
        "Send test traffic from traffic generator", 
        "Verify packet counts are approximately equal on all ports"
      ],
      "testdata": {
        "num_ports": 8,
        "expected_deviation": 10
      }
    },
    "testscript": {
      "testname": "ECMP Load Balancing - Port 2",
      "objective": "Generate and send test traffic for port 2",
      "file_name": "port2_traffic.py",
      "init_scripts": [
        "pip install scapy",
        "pip install paramiko",
        """
        import paramiko 
        import time
        from scapy.all import *
        
        #Send test traffic
        src_mac = "00:00:00:00:00:01" 
        dst_mac = "00:00:00:00:00:02"
        
        for i in range(100):
            sendp(Ether(src=src_mac, dst=dst_mac)/IP(dst="10.0.0.1")/TCP())
            time.sleep(1)
        """,
        "python port2_traffic.py",
        "No errors while generating and sending test traffic on port 2."
      ]
    }
  }
]
###ENDLIST###